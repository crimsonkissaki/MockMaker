<?php

/**
 * TestEntityMock
 *
 * Automatically generated by MockMaker.
 *
 * @author      MockMaker
 * @created     2015-05-03
 */

namespace MockMaker\Mocks;

use MockMaker\Entities\TestEntity;
use MockMaker\Entities\SimpleEntity;
use stdClass;
use DateTime;
use MockMaker\Helper\TestHelper;

class TestEntityMock
{

    /**
     * Returns array of minimum required properties for generating
     * a valid TestEntity mock file
     *
     * This associative array format of TestEntity's elements
     * allows for simple customization of how the class mock is hydrated.
     *
     * It's best to remove any properties that are not absolutely necessary for
     * instantiating a new TestEntity object. However,
     * it is still possible to ignore any of these on an at-will basis when
     * creating a new mock if the property is used enough that you want to
     * leave it in here to save work. See getMock() documentation for details.
     *
     * Since MockMaker already does a best guess attempt at detecting setters and
     * inserts them here if it finds one, if the 'setter' element of this array is
     * '' or boolean false MockMaker will assume the property has no setter
     * and needs to be manipulated through reflection.
     *
     * @return  array
     */
    public static function getMandatoryProperties()
    {
        return array(
            'privateProperty1' => 'privateProperty1 value',
            'privateProperty2' => 'privateProperty2 value',
            'privatePropertyDefaultValueAssignedByConstructor' => new SimpleEntity(),
            'privatePropertyDefaultValueAssignedByConstructorTopLevelClass' => new DateTime(),
            'protectedProperty1' => 'protectedProperty1 value',
            'protectedProperty2' => 'protectedProperty2 value',
            'protectedPropertyDefaultValueAssignedByConstructor' => new SimpleEntity(),
            'protectedPropertyDefaultValueAssignedByConstructorTopLevelClass' => new stdClass(),
            'publicORMSimpleEntityProperty' => NULL,
            'publicORMEntityThatExtendsProperty' => NULL,
            'publicProperty1' => 'publicProperty1 value',
            'publicProperty2' => 'publicProperty2 value',
            'publicPropertyDefaultValueAssignedByConstructor' => new SimpleEntity(),
            'publicPropertyDefaultValueAssignedByConstructorTopLevelClass' => new DateTime(),
            'publicStaticProperty1' => 'publicStaticProperty1 value',
            'publicStaticProperty2' => 'publicStaticProperty2 value',
            'privateStaticProperty1' => 'privateStaticProperty1 value',
            'privateStaticProperty2' => 'privateStaticProperty2 value',
            'protectedStaticProperty1' => 'protectedStaticProperty1 value',
            'protectedStaticProperty2' => 'protectedStaticProperty2 value',
        );
    }

    /**
     * Customized generation of mock TestEntity objects
     *
     * @param	array|null  $properties
     * null (default): Returns a 'bare bones' mock. Any properties in the
     * 'mandatoryProperties' array will be hydrated based on the defined
     * 'setter' method and 'default' value.
     *
     * array: Associative array in 'property' => 'value' format.
     * Returns a mock hydrated with given values for given properties.
     * Any properties specified in the 'mandatoryProperties' array that are
     * not supplied in the array will be hydrated based on the defined 'setter'
     * method and 'default' value.
     *
     * @param	array|null  $ignore
     * Properties that you want getMock() to completely ignore while
     * hydrating the mock object. Overrides properties defined in the
     * 'mandatoryProperties' array.
     *
     * @return	TestEntity
     */
    public static function getMock($properties = [], $ignore = [])
    {
        // fix for properties that are not passed in with values
        // and need to be assigned a null default
        foreach($properties as $key => $value ) {
            if(is_int($key)) {
                $properties[$value] = null;
                unset($properties[$key]);
            }
        }
        $defaults = self::getMandatoryProperties();
        $mock = new TestEntity();
        $reflection = new \ReflectionClass('MockMaker\Entities\TestEntity');

        $constant = array('CONSTANT_PROPERTY1', 'CONSTANT_PROPERTY2');

        foreach( $defaults as $property => $default ) {
            if(!in_array($property, $ignore) ) {
                $value = (isset($properties[$property])) ? $properties[$property] : $defaults[$property];
                if(!in_array($property, $constant)) {
                    $r_prop = $reflection->getProperty($property);
                    $r_prop->setAccessible(true);
                    $r_prop->setValue($mock, $value);
                }
            }
        }

        foreach( $properties as $property => $value ) {
            if(!in_array($property, $ignore) ) {
                if(!in_array($property, $constant)) {
                    $r_prop = $reflection->getProperty($property);
                    $r_prop->setAccessible(true);
                    $r_prop->setValue($mock, $value);
                }
            }
        }

        return $mock;
    }

}