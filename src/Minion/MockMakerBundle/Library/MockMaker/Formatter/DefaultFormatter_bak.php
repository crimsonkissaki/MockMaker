<?php

/**
 *	DefaultFormatter
 *
 *	Default code generator formatter for MockMaker
 *
 *	@author		Evan Johnson <evan.johnson@rapp.com>
 *	@created	Apr 16, 2015
 *	@version	1.0
 */

namespace Minion\MockMakerBundle\Library\MockMaker\Formatter;

use Minion\MockMakerBundle\Library\MockMaker;
use Minion\MockMakerBundle\Library\MockMaker\Formatter\FormatterInterface;
use Minion\MockMakerBundle\Library\MockMaker\Worker\StringFormatterWorker;

use Minion\UnitTestBundle\Library\DebuggerMinion;

/**
 * Todo:
 * allow for dynamic setting of the method to use for generating the reflection code
 *
 */
class DefaultFormatterBackup implements FormatterInterface
{

	/**
	 * Format string used when generating class & file names.
	 *
	 * Will be used in generating the generated file names.
	 * Allows substitution of pre-set values into the name.
	 *
	 * Substitution Values:
	 *  ClassName
	 *
	 * Example: '%ClassName%Mock.php'
	 *
	 * @var	string
	 */
	private $classNameFormat = '%ClassName%Mock';

	/**
	 * Formatted class name.
	 *
	 * @var	string
	 */
	private $formattedClassName;

	/**
	 * Name to use for the advanced method argument.
	 *
	 * @var string
	 */
	private $advancedMethodArgumentName = 'properties';

	/**
	 * Get the format string used when generating class & file names.
	 *
	 * @return	string
	 */
	public function getClassNameFormat()
	{
		return $this->classNameFormat;
	}

	/**
	 * Get the argument name to use in the advanced method.
	 *
	 * @return	string
	 */
	public function getAdvancedMethodArgumentName()
	{
		return $this->advancedMethodArgumentName;
	}

	/**
	 * Set the format string used when generating class & file names.
	 *
	 * @param	$classNameFormat	string
	 */
	public function setClassNameFormat( $classNameFormat )
	{
		$this->classNameFormat = $classNameFormat;
	}

	/**
	 * Set the argument name to use in the advanced method.
	 *
	 * @param	$advancedMethodArgumentName		string
	 */
	public function setAdvancedMethodArgumentName( $advancedMethodArgumentName )
	{
		$this->advancedMethodArgumentName = $advancedMethodArgumentName;
	}

	/**
	 * Generate the base code for mocking an object with default values.
	 *
	 * @param	$mockMaker	MockMaker
	 * @return	string
	 */
	public function generateMockCode( MockMaker $mockMaker )
	{
		$this->formattedClassName = $this->formatClassName( $mockMaker->getClassShortName() );
		return <<<CODE
<?php

{$this->generateClassCommentCode( $mockMaker )}

{$this->generateClassUseStatements( $mockMaker )}

{$this->generateClassBasicFunctionalCode( $mockMaker )}

{$this->generateClassAdvancedFunctionalCode( $mockMaker )}

CODE;
	}

	/**
	 * Generate the final class name.
	 *
	 * @param	$classShortName		string
	 */
	public function formatClassName( $classShortName )
	{
		return StringFormatterWorker::vsprintf2( $this->classNameFormat, array('ClassName'=>$classShortName) );
	}

	/**
	 * Generate the class file's use statements
	 *
	 * @param	$mockMaker	MockMaker
	 * @return	string
	 */
	private function generateClassUseStatements( MockMaker $mockMaker )
	{
		return <<<CODE
namespace {$mockMaker->getMockNamespace()};

use {$mockMaker->getClassFullName()};
use RAPP\Bundle\LoyaltyBundle\Tests\Helpers\TestHelper;
CODE;
	}

	/**
	 * Generate the class file's comment code
	 *
	 * @param	$mockMaker	MockMaker
	 * @return	string
	 */
	private function generateClassCommentCode( MockMaker $mockMaker )
	{
		$today = new \DateTime('now');
		$date = $today->format('Y-m-d');

		return <<<COMMENTS
/**
 * {$this->formattedClassName};
 *
 * Automatically generated by MockMaker
 *
 * @author		MockMaker
 * @created		{$date}
 */
COMMENTS;
	}

	/**
	 * Generate the class file's basic functional code
	 *
	 * @param	$mockMaker	MockMaker
	 * @return	string
	 */
	private function generateClassBasicFunctionalCode( MockMaker $mockMaker )
	{
		return <<<CODE
class {$this->formattedClassName}
{

	/**
	 * Generate a mock {$mockMaker->getClassShortName()} object.
	 *
	 * Public setter methods are straightforward.
	 * Private/Protected setters require reflection to make them work.
	 *
	 * @return	{$this->formattedClassName}
	 */
	public static function getBasicMock()
	{
		\$mock = new {$mockMaker->getClassShortName()}();

{$this->generateAssignmentCodeForSetters( $mockMaker )}
{$this->generateAssignmentCodeForPropertiesWithoutSetters( $mockMaker )}

		return \$mock;
	}
CODE;
	}

	/**
	 * Generate the class file's advanced functional code
	 * This method allows for passing in an associative
	 * array of ( 'property' => 'value' ) pairs to dynamically
	 * set the values of the mock object at runtime.
	 *
	 * @param	$mockMaker	MockMaker
	 * @return	string
	 */
	private function generateClassAdvancedFunctionalCode( MockMaker $mockMaker )
	{
		return <<<CODE
	/**
	 * Generate a mock {$mockMaker->getClassShortName()} object.
	 *
	 * Public setter methods are straightforward.
	 * Private/Protected setters require reflection to make them work.
	 *
	 * This method allows for passing in an associative array of
	 * ( 'property' => 'value' ) pairs to dynamically set the mock's
	 * values at runtime.
	 *
	 * @param	\${$this->getAdvancedMethodArgumentName()}	array
	 * @return	{$this->formattedClassName}
	 */
	public static function getAdvancedMock( \${$this->getAdvancedMethodArgumentName()} )
	{
		\$mock = new {$mockMaker->getClassShortName()}();

{$this->generateAssignmentCodeForSetters( $mockMaker, TRUE )}
{$this->generateAssignmentCodeForPropertiesWithoutSetters( $mockMaker, TRUE )}

		return \$mock;
	}

	/**
	 * Prevent 'undefined index' errors for getAdvancedMock().
	 *
	 * This checks to see if the property exists in the getAdvancedMock()
	 * argument array and returns it. Otherwise it returns a default value.
	 *
	 * The defaultValuesArray is pre-populated with a 'best guess' default
	 * based on the method's argument data.
	 *
	 * @param	\$argArr	array	Argument array submitted to getAdvancedMock()
	 * @param	\$property	string	Property we're looking for in the argArr
	 * @return	mixed
	 */
	public static function getArgVal( \$argArr, \$property )
	{

{$this->generateDefaultValuesArrayCode( $mockMaker )}

		return ( isset(\$argArr[\$property]) ) ? \$argArr[\$property] : \$defaultValuesArray[\$property];
	}

}
CODE;
	}

	/**
	 * Generate setter method execution code.
	 *
	 * @param	$mockMaker	MockMaker
	 * @param	$advanced	bool		Use 'advanced' formatting & include property array argument as value.
	 * @return	string
	 */
	private function generateAssignmentCodeForSetters( MockMaker $mockMaker, $advanced = FALSE )
	{
		$code = '';
		//DebuggerMinion::dbug( $mockMaker, "MockMaker values", TRUE );
		//foreach( $mockMaker->getClassMethods() as $scope => $methods ) {
		foreach( $mockMaker->getClassMethodDetails() as $scope => $methods ) {
			if( !empty($methods) ) {
				foreach( $methods as $key => $method ) {
					$code .= $this->generateSetterMethodCode( $scope, $method, $advanced );
				}
			}
		}

		return rtrim( $code, PHP_EOL);
	}

	/**
	 * Generate the setter method code.
	 *
	 * @param	$scope		string				Scope of the method
	 * @param	$method		\ReflectionMethod
	 * @param	$advanced	bool				Use 'advanced' formatting & include property array argument as value.
	 * @return	string
	 */
	private function generateSetterMethodCode( $scope, $method, $advanced )
	{
		$code = '';
		$value = $this->getMethodArgumentValue( $method, $advanced );
		if( $method->isSetter ) {
			$mName = $method->name;
			if( in_array( $scope, array('public') ) ) {
				$code .= "		\$mock->{$mName}( {$value} );" . PHP_EOL;
			}
			if( in_array( $scope, array('private', 'protected') ) ) {
				//$code .= "		\$r_{$mName} = \$this->getAccessibleNonPublicMethod( \"{$mName}\" );" . PHP_EOL;
				$code .= "		\$r_{$mName} = TestHelper::getAccessibleNonPublicMethod( \"{$mName}\" );" . PHP_EOL;
				$code .= "		\$r_{$mName}->invoke( \$mock, {$value} );" . PHP_EOL;
			}
		}

		return $code;
	}

	/**
	 * Get the value to be inserted into the method calls in the generated
	 * mock code.
	 *
	 * @param	$method		MethodDetails
	 * @param	$advanced	bool
	 * @return	string
	 */
	private function getMethodArgumentValue( $method, $advanced )
	{
		if( $advanced ) {
			$property = lcfirst( str_replace( 'set', '', $method->name ) );
			$value = "self::getArgVal( \${$this->getAdvancedMethodArgumentName()}, '$property' )";
		} else {
			$value = "''";
		}

		return $value;
	}

	/**
	 * Get the value to be inserted into the no setter calls in the generated
	 * mock code.
	 *
	 * @param	$name		string		Parameter name.
	 * @param	$advanced	bool		Advanced or basic method.
	 * @return	string
	 */
	private function getNoSetterArgumentValue( $name, $advanced )
	{
		if( $advanced ) {
			$value = "self::getArgVal( \${$this->getAdvancedMethodArgumentName()}, '$name' )";
		} else {
			$value = "''";
		}

		return $value;
	}

	/**
	 * Generate execution code for properties that do not have setters.
	 *
	 * @param	$mockMaker	MockMaker
	 * @param	$advanced	bool		Use 'advanced' formatting & include property array argument as value.
	 * @return	string
	 */
	private function generateAssignmentCodeForPropertiesWithoutSetters( MockMaker $mockMaker, $advanced = FALSE )
	{
		$code = '';
		foreach( $mockMaker->getClassPropertyDetails() as $scope => $properties ) {
			if( !empty($properties) ) {
				foreach( $properties as $key => $property ) {
					if( !$property->setter ) {
						$code .= $this->generateNoSetterPropertyCode( $scope, $property->name, $advanced );
					}
				}
			}
		}

		return rtrim( $code, PHP_EOL );
	}

	/**
	 * Generate code for setting the value of a property that has no default setter.
	 *
	 * @param	$scope		string
	 * @param	$name		string
	 * @param	$advanced	bool		Use 'advanced' formatting & include property array argument as value.
	 * @return	string
	 */
	private function generateNoSetterPropertyCode( $scope, $name, $advanced )
	{
		$value = $this->getNoSetterArgumentValue( $name, $advanced );
		if( in_array( $scope, array('public') ) ) {
			return "		\$mock->{$name} = {$value};" . PHP_EOL;
		}
		if( in_array( $scope, array('private', 'protected') ) ) {
			//return "		\$this->setNonPublicValue( \$mock, \$mock, '$name', 'value' );" . PHP_EOL;
			return "		TestHelper::setNonPublicValue( \$mock, \$mock, '$name', {$value} );" . PHP_EOL;
		}

		return "";
	}

	/**
	 * Generate the defaultValuesArray used in the getArgVal() method.
	 *
	 * @param	$mockMaker	MockMaker
	 * @return	string
	 */
	private function generateDefaultValuesArrayCode( MockMaker $mockMaker )
	{
		$classProperties = $mockMaker->getClassPropertyDetails();

		DebuggerMinion::dbug( $classProperties, "property details" );

		$code = '';
		$code .= '		$defaultValuesArray = array(' . PHP_EOL;
		foreach( $classProperties as $scope => $properties ) {
			$code .= $this->generateDefaultPropertiesValueElement( $scope, $properties, $mockMaker->getClassShortName() );
		}
		$code .= '		);';

		return $code;
	}

	/**
	 * Generate the array element for use in the defaultValuesArray.
	 *
	 * @param	$scope			string		Property visibility.
	 * @param	$properties		array		Array of PropertyDetails objects
	 * @param	$className		string		Class name that's being mocked
	 * @return	string
	 */
	private function generateDefaultPropertiesValueElement( $scope, $properties, $className )
	{
		//DebuggerMinion::dbug( $properties, "property", TRUE );
		$code = '';
		foreach( $properties as $k => $property ) {
			//if( in_array( $scope, array( 'constant', 'static' ) ) ) {
			if( $scope === 'constant' || $property->isStatic ) {
				$code .= "			'{$property->name}' => '{$className}::{$property->name}'," . PHP_EOL;
			} else {
				if( !$property->isStatic ) {
					$code .= "			'{$property->name}' => '{$property->defaultValue}'," . PHP_EOL;
				}
			}
		}


		return $code;
	}

	/**
	 * Insert this method into your generated code if you do NOT already
	 * have a method set up somewhere to handle non-public PROPERTIES.
	 *
	 * @return	string
	 */
	private function generatePrivateValueMethodCode()
	{
		$code = '';
		if( !empty($this->methods['private']) || !empty($this->methods['protected']) ) {
			$code = <<<CODE
/**
	 * This uses reflection to set the value of a private/protected parameter
	 * to a desired value.
	 *
	 * Unless you're changing the values of a Mockery/Prophecy created object,
	 * you can usually pass the same object as the first 2 parameters.
	 *
	 * Warning! Uses pass-by-reference!
	 *
	 * @param	\$objToChange		object
	 * @param	\$objToReflect		mixed
	 * @param	\$property			string
	 * @param	\$value				string
	 */
	private function setNonPublicValue( &\$objToChange, \$objToReflect, \$property, \$value )
	{
		\$class = (is_object(\$objToReflect)) ? get_class(\$objToReflect) : \$objToReflect;
		\$refClass = new \ReflectionClass( \$class );
		\$refProp = \$refClass->getProperty(\$property);
		\$refProp->setAccessible(true);
		\$refProp->setValue(\$objToChange, \$value);
	}

CODE;
		}

		return $code;
	}

	/**
	 * Insert this method into your generated code if you do NOT already
	 * have a method set up somewhere to handle non-public METHODS.
	 *
	 * @return	string
	 */
	private function generatePrivateMethodMethodCode()
	{
		$code = '';
		if( !empty($this->methods['private']) || !empty($this->methods['protected']) ) {
			$code = <<<CODE
/**
	 * Make non-public methods accessible.
	 *
	 * @param	\$methodName	string	Method you want to make public
	 * @return	\ReflectionMethod
	 */
	private function getAccessibleNonPublicMethod( \$methodName )
	{
		\$reflection = new \ReflectionClass("{$this->classFullName}");
		\$method = \$reflection->getMethod( \$methodName );
		\$method->setAccessible( TRUE );

		return \$method;
	}

CODE;
		}

		return $code;
	}

}
